
Алгоритм : в элементе #before и #after находим максимальное количество пар элементов которые можно считать не изменёнными. Из оставшихся выделяется максимальное количество пар с расчётом на то что изменения между ними можно подать как замену innerHTML. Остальные элементы считаются удалёнными и добавлеными.

Детальнее.

Функция diff() определяет элементы с индексами before и after, и подаёт их в качестве аргументов в функцию compare().

Функция compare() сравнивает элементы a и b на равенство типов, равенство текстового контента, и если они совпадают, то формирует 
массивы их дочерних элементов. Далее в них функцией make_list выделяется найбольшее количество общих элементов, после чего каждая пара из этих общих элементов рекурсивно сравнивается этой же функцией (compare). В случае неравенства типов элементы считаются разными, тоесть элемент из before считается удалённым, элемент из after - добавленым. Если разный только текст то элемент считается изменённым.

Функция make_list() находит найбольшую последовательность элементов такую, что она входит в  а и b. Другими словами - найбольшую общую 
подпоследовательность масссивов a и b. Для этого используется метод динамического программирования. Заведём двумерный массив A[i][j].
Пусть элемент A[i][j] - длина найбольше общей подпоследовательности, при условии что массив а рассматривается с 0 элемента по i, а массив b с 0 по j.
Тогда очевидно, что ответом будет A[a.length][b.length]. Определим способ вычисления A[i][j] элемента. Допустим a[i] = b[j]. Тогда
A[i][j] = A[i-1][j-1]+1, поскольку можно использовать найбольшую общую подпоследовательность не включая последние элементы (A[i-1][j-1]) 
и добавит последний общий конечный элемент (+1). В итоге получаем условие    Если a[i] = b[j] то A[i][j]=A[i-1][j-1]+1. Рассмотрим случай 
когда a[i] не равно b[j]. По такой же логике получаем что A[i][j] = maximum (A[i-1][j],A[i-1][j-1],A[i][j-1]). Это выражение можно сократить,
так как очевидно что A[i-1][j] >= A[i-1][j-1] и A[i][j-1] >= A[i-1][j-1]. Получаем условие     
Если a[i] не равно b[j] то A[i][j] = maximum (A[i-1][j],A[i][j-1])
В качестве начаоьных элементов воьзмём A[x][0] и A[0][x]. Они равны 0 поскольку один из индексов 0.
Вычислив матрицу A можно легко определить какие именно элементы были использованы. Достаточно каждый раз искать текущий максимальный элемент
который находится как можно левее и выше (по сути, элемент на котором последний раз выполнялось условие a[i] = b[j]), но этого не достаточно. Так можно
найти только тип необходимого элемента (будем называть его ключевой тип), а не конкретный элемент, поскольку мы не берём в расчёт текст внутри элементов (тоесть мы находим, к примеру, первые 2 элемента из четырёх
и запоминаем именно их, хотя позже может встретится элемент такого же типа, но текст внутри него будет полностью совпадать с аналогом в #before, в отличии от первых двух). Поэтому
в функции после вычисления матрицы A и ключевых типов, вычесляется какие конкретно элементы использованы.
Дополнительное уточнение выполняется в целях минимализации изменений. Пример такого улучшения можно посмотреть в 3 и 4 примере папки examples.

Поиск конкретного элемента (тоесть элемента который не только совпадает по типу, а и по тексту содержания) выполняется в пределах
соседей k-го элемента с ключевым типом массива ans_mas_a для массива а, и массива ans_mas_b для массива b соответственно. Тоесть от ans_mas_a[k+1] до ans_mas_a[k-1]
относительно массива а (от большего к меньшему индексу поскольку в ходе алгоритма массив переворачивается). Аналогично для b.
Также в начале цикла отдельно рассмотрены случаи, когда k = 0 либо k = maximum, тоесть когда невозможно определить элементы с индексом k+1 либо k-1.

